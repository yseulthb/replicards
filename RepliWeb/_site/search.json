[
  {
    "objectID": "replicards.html",
    "href": "replicards.html",
    "title": "\nThe Replicards\n",
    "section": "",
    "text": "Concept by Elia Mascolo* and Yseult H√©jja-Brichard\nThe aim of this interactive class is to demonstrate how replicants that can inherit mutations can undergo evolution by natural selection if the inheritable characteristics can affect their reproductive success."
  },
  {
    "objectID": "replicards.html#protocol",
    "href": "replicards.html#protocol",
    "title": "\nThe Replicards\n",
    "section": "Protocol",
    "text": "Protocol\nEach student was provided with a deck of square cards showing an empty \\(8 \\times 8\\) grid. This deck of cards was available to the students for the whole duration of the class.\n\n\n\n\nFig. 1 - This is the image caption.\n\n\n\nSteps in each generation\nThe experiment consists of repeating a procedure called a generation several times. Each generation consists of the following three steps:\n\n1. The memorization phase (\\(10\\) seconds)\nEach student was provided with a template card, on which some cells of the grid were crossed with an X, forming a pattern. For example, a pattern may look like this:\n\n\n\n\nFig. 2 - This is the image caption.\n\n\nHowever, the template card was provided face down, so that the students could not see the pattern.\nDuring the memorization phase, the students were allowed to look at the pattern on their template card for \\(10\\) seconds and asked to try to memorize it. At the end of the \\(10\\) seconds, the students had to turn the template card face down again.\n\n\n2. The replication phase (\\(30\\) seconds)\nAs soon as they had turned the template face down, they had to copy the observed pattern onto the empty cards they were provided (without being able to look at the template again). They were asked to try to create as many correct copies of the template as possible over \\(30\\) seconds. They were told that translations or rotations of the pattern on the grid count as correct replicas. For example, the following three cards display the same pattern.\n\n\n\n\nFig. 3 - This is the image caption.\n\n\n\n\n3. The competition phase\nThe templates were collected into a pile called the ‚Äúgeneration record‚Äù, which was put aside. Instead, the replicas were all put into a bag. The number of replicas largely exceeded the number of students. Each student was then randomly assigned a new template card randomly drawn from the bag. The remaining cards in the bag were discarded.\nOnce each student has a new template, a new generation can start. The process is repeated until a desired number of generations is reached.\n\n\n\nRecording results\nFor each generation, the pile of template cards was collected (the ‚Äúgeneration record‚Äù). Therefore, we had one pile of \\(N\\) cards per generation (where \\(N\\) is the number of students in the class). For each pile, the number of copies of each type of pattern was counted. Translated or rotated patterns count as the same pattern (see Fig XXX).\nThe obtained counts were organized into a table."
  },
  {
    "objectID": "replicards.html#results",
    "href": "replicards.html#results",
    "title": "\nThe Replicards\n",
    "section": "Results",
    "text": "Results\nThe class was composed of \\(24\\) students (\\(N=24\\)). At generation 0, the ‚Äúpopulation‚Äù of template cards that had been distributed to the students was composed of the following three patterns (8 copies each):\n\n\n\n\nFig. 4 - This is the image caption.\n\n\nWe named the patterns with the letters A, B and C.\nThe results of the experiment are summarized in the following table.\n\n\n\nGeneration\nA\nB\nC\n\n\n\n\n0\n8\n8\n8\n\n\n1\n16\n1\n2\n\n\n2\n21\n1\n0\n\n\n\nWe can also visualize the number of A, B and C over generations through a line plot as follows.\n\nimport matplotlib.pyplot as plt\nplt.rcParams['figure.figsize'] = [5, 2.5]\nplt.plot([8, 16, 21], label='A')\nplt.plot([8,  1,  1], label='B')\nplt.plot([8,  2,  0], label='C')\nplt.xticks(list(range(3)))\nplt.xlabel('generation')\nplt.ylabel('number of individuals')\nplt.grid()\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nüëÄ The students were asked to comment on the results shown in the table. They made two observations:\n\nObservation 1:\nThe number of A cards increased each generation, while the number of B and C types decreased very quickly.\nObservation 2:\nThe total number of A, B and C cards in generations \\(1\\) and \\(2\\) is no longer \\(24\\), even though in each generation one card was assigned to each student (so \\(24\\) in total).\n\nüí° Students were asked to explain the observations.\n\nInterpretation of Observation 1 (Hypothesis 1):\nThe students noted that reproducing pattern A was easier than reproducing patterns B or C. More copies of A were generated in each generation and, therefore, the bag contained more copies of A than the other types of patterns. As a consequence, students were more likely to receive an A card in the next generation, when cards were randomly drawn from the bag.\nInterpretation of Observation 2 (Hypothesis 2):\nOne student suggested that, due to copying errors, some cards in generations \\(1\\) and \\(2\\) may not correspond to any of the three original patterns, A, B and C. That could explain why the count of A+B+C was no longer \\(24\\).\n\nüîç We then tested the students‚Äô explanations.\n\nTesting Hypothesis 1\nBy looking at cards that went into the bag at the end of generation 0, which had been kept aside, we could test Hypothesis 1. The majority of the cards were of type A, confirming that more copies of A were produced, compared to B and C cards, although the templates were 8 per type and they all had the same amount of replication time. Hypothesis 1 was confirmed.\nTesting Hypothesis 2\nBy inspecting the piles of cards for generations \\(1\\) and \\(2\\) (the ‚Äúgeneration records‚Äù), we found some cards that didn‚Äôt correspond to any of the three original patterns A, B and C. These cards were termed mutants. The mutants were \\(5\\) in generation 1 and \\(2\\) in generation 2 (see Mutants, below). When taking the mutants into account, the total number of cards per generation was indeed \\(24\\). Hypothesis 2 was confirmed.\n\n\nMutants\nMutants at generation \\(1\\):\n\n\n\n\nFig. 5 - This is the image caption.\n\n\nMutants at generation \\(2\\):\n\n\n\n\nFig. 6 - This is the image caption.\n\n\nThus, we updated the table to account for the mutants. This way, all the cards were counted at each generation. For simplicity, we categorized all the mutants under a single class named X.\n\n\n\nGeneration\nA\nB\nC\nX\n\n\n\n\n0\n8\n8\n8\n0\n\n\n1\n16\n1\n2\n5\n\n\n2\n21\n1\n0\n2"
  },
  {
    "objectID": "replicards.html#conclusions",
    "href": "replicards.html#conclusions",
    "title": "\nThe Replicards\n",
    "section": "Conclusions",
    "text": "Conclusions\nWe concluded that the frequency of each type of pattern can change across generations due to chance (after all, the cards composing each new generation are randomly sampled from the bag) but also partly due to another logical principle. The principle is the following: if a pattern is more successful at being replicated than the others, its frequency in the population is more likely to increase. Now that we understand these two principles acting on the frequencies of the competing replicants, we are ready to name them according to the scientific literature:\n\nGENETIC DRIFT: the (unpredictable) effect that random chance has on the frequency of each type of replicant.\nNATURAL SELECTION: the (predictable) bias in the frequency of each type of replicant due to their (different) reproductive success.\n\nThe overall process that the population of \\(N\\) replicants underwent, where the frequencies of the different types change over generations, is called EVOLUTION.\n\nHomework questions\n\nQuestion 1\nWe discussed that evolution is not completely predictable because chance is involved in several parts of the process. However, some scenarios may be more/less predictable than others. As an exercise, try to think about the role that the population size \\(N\\) plays. For example, compare the scenarios where \\(N\\) is very small/very large. Which one will evolve in a more predictable way?\n\n\nQuestion 2\nThe balance between genetic drift and natural selection (see Conclusions to check the terminology) can also depend on the difference in reproductive success (evolutionary biologists use the term fitness) between the different types of replicants. Compare the scenarios where the types are very similar/very different in reproductive success. Which one will evolve in a more predictable way?"
  },
  {
    "objectID": "replicards.html#evolutionary-simulations",
    "href": "replicards.html#evolutionary-simulations",
    "title": "\nThe Replicards\n",
    "section": "Evolutionary simulations",
    "text": "Evolutionary simulations\nThe experiment we performed with the replicards is a demonstration of how evolution by natural selection works. However, it has two important limitations: 1. We only run a couple of generations, but it would be interesting to follow the evolution of the replicards through many generations. 2. We only experimented with a given initial condition (patterns A, B and C in equal frequencies), but it would be interesting to test patterns that are more different or more similar to each other in terms of their reproductive success.\nTo that end, we can use computer simulations to get very quick empirical answers to our questions.\n\nThe virtual replicards\nWe can use the Python programming language to run computer simulations of the replicards‚Äô evolution, by importing the code (XXX). Specifically, we will import the following types of Pthon classes\n\nOrganism : objects of this class represent the individuals composing the population (like the replicards); they can reproduce (i.e., create a copy of themselves).\nPopulation : this is a handy class that can be used to generate reports of the evolution of a population; it can visually summarize the results of a simulation with a plot.\n\nas well as the create function\n\ncreate : a function that can be used to generate the initial population. It requires to specify three parameters: (1) the type of organism, i.e., whatever name that identifies that type; (2) the (expected) reproductive success of that type of organism; (3) the number of organisms of that type that must be created.\n\nThe code is imported as follows.\n\nimport random\nfrom evo_sim_objects import Population, create\n\n\n\nSettings\nWe can now set the initial condition (the population at ‚ÄúGeneration 0‚Äù) for our evolutionary simulation.\nFirst, we set how many ‚Äúorganisms‚Äù per type are present at the beginning. Here we simulate the in-class experiment by setting three patterns, 8 copies each, for a total population size of \\(N=24\\).\n\nn_a = 8  # Initial number of A\nn_b = 8  # Initial number of B\nn_c = 8  # Initial number of C\n\nNext, we can decide how easy it will be to replicate each type of pattern, by setting the expected (average) number of copies each pattern get at each generation.\n\nw_a = 12  # Expected number of offspring for A per generation\nw_b =  8  # Expected number of offspring for B per generation\nw_c =  4  # Expected number of offspring for C per generation\n\n\n\nRun the evolutionary simulation\nWe are now ready to run a computer simulation.\n\nimport random\nfrom evo_sim_objects import Population, create\n\n# Initialize population\npop = Population(create('A', w_a, n_a) +\n                 create('B', w_b, n_b) +\n                 create('C', w_c, n_c))\n\n# Population size\nN = pop.size\nprint(\"The population size is N =\", N)\n\n# Keep evolving until fixation is reached\nwhile not pop.fixation:\n    \n    # Reproduction based on fitness\n    pop_offspring = []\n    for org in pop.organisms:\n        pop_offspring += org.reproduce()\n    parents_and_offspring = pop.organisms + pop_offspring\n    \n    # Maintain population size constant at N, the environment's carrying capacity\n    new_pop = random.sample(parents_and_offspring, N)\n    \n    # Update the population\n    pop.update(new_pop)\n\n# Plot results of the evolutionary simulation\npop.plot_evolution()\n\nThe population size is N = 24\n\n\n\n\n\n\n\n\n\nThe graph displays how many individuals of each type are present in each generation, while the total population size remains constant. The simulation stopped when one of the types took over the population completely.\n\n\nRun your own experiments\nIf you are running this as a Jupyter Notebook, you can go back to the Settings and change the parameters that specify the initial conditions. In particular, if you have thought about the Homework questions, it is time for you to put your thoughts to the test! For example, to get the answer to Question 1, you can change the population size to make it very big or very small, and run the simulation several times to see if results become more consistent or more unpredictable. Similarly, for Question 2 you can play with the w_a, w_b and w_c parameters, which control the reproductive success (the ‚Äúfitness‚Äù) of each type. You can make it more unequal (for example, 12, 2, 1) or more similar to each other (for example, 12, 11, 10)."
  },
  {
    "objectID": "replicards.html#in-class-discussion",
    "href": "replicards.html#in-class-discussion",
    "title": "\nThe Replicards\n",
    "section": "In-class discussion",
    "text": "In-class discussion\n\nRandomness\nWhen running the same simulation (with the same initial population) several times, we observed different outcomes. Why is that?\nIn the code, the w_a, w_b and w_c parameters define the average number of offspring per generation. However, the exact number of offspring is randomly assigned (if you are statistically minded, the precise way this is done is by sampling from a Poisson distribution). Moreover, at each generation, \\(N\\) individuals are randomly sampled (to keep the population size constant). These random processes make the evolution to some extent unpredictable. Thus, they simulate the phenomenon that we called genetic drift (see Conclusions to check the terminology).\nThe computer simulations can help us demonstrate empirically the balance between random chance and natural selection in evolving populations (see the paragraph ‚ÄúRun your own experiments‚Äù).\n\n\nMutations\nHowever, a limitation of our computer simulations is that the replication occurs without errors. No mutations are introduced, and therefore, no new types. On the contrary, the experiment performed by the students with the replicards included accidental mutations, allowing for the appearance of mutants.\n\nWhat is a mutation?\n\nWe reasoned that not all modifications qualify as mutations. For example, a card got bent during the replication process. However, when being used as a template, the copies of that card (the ‚Äúoffspring‚Äù) were not bent because the students were only copying the pattern of X marks, not every possible physical feature. Evolution acts on mutations, which are not any kind of modifications but rather the modification of inheritable traits. In the case of the replicards, the inheritable traits are the positions of the X marks, which are a form of digital information. Actual living beings don‚Äôt carry grids of X marks, but rather a sequence of nucleotides making a long molecule called DNA, which is also a form of digital information. Modifying other parts of the organism would constitute a modification but not a mutation. For example, if I lose a finger in an accident, my children will still be born with 10 fingers, not 9. Instead, if the DNA sequence in my ‚Äúgermline‚Äù cells gets mutated in some parts (genes) related to finger development (for example, HoxA and HoxD genes), my offspring could have a number of fingers different from 10, even if I have 10 fingers (as in the case of people with polydactyly).\n\nWhat do you think could happen if we were to continue the replicards protocol for a very very large number of generations?\n\nA student suggested that eventually the population would be taken over by a replicard containing a single X. This pattern could be produced if, at the end of the 30 seconds of the replication phase, a student had just started making a new copy of the template. The prematurely interrupted replication process would leave the card filled with only one X mark. If this card is lucky enough to be sampled from the bag, it could end up dominating the population due to its high reproductive success (high fitness). This high success would be simply due to the fact that many more copies of it could be made in 30 seconds, compared to other more complicated patterns."
  },
  {
    "objectID": "replicards.html#phylogenesis",
    "href": "replicards.html#phylogenesis",
    "title": "\nThe Replicards\n",
    "section": "Phylogenesis",
    "text": "Phylogenesis\nXXX Text here ‚Ä¶"
  },
  {
    "objectID": "replicards.html#materials-and-methods",
    "href": "replicards.html#materials-and-methods",
    "title": "\nThe Replicards\n",
    "section": "Materials and Methods",
    "text": "Materials and Methods\n\nReplicards\nThe replicards were \\(7 \\times 7\\) square grids (of size 7 cm \\(\\times\\) 7 cm), printed on thick paper. The X marks on the cells were drawn by the students using pencils.\n\n\nSimulations\nThe code was written in Python and is available at XXX."
  },
  {
    "objectID": "replicards.html#acknowledgements",
    "href": "replicards.html#acknowledgements",
    "title": "\nThe Replicards\n",
    "section": "Acknowledgements",
    "text": "Acknowledgements"
  },
  {
    "objectID": "src/replicards/replicards.html",
    "href": "src/replicards/replicards.html",
    "title": "\nThe Replicards\n",
    "section": "",
    "text": "Concept by Elia Mascolo* and Yseult H√©jja-Brichard"
  },
  {
    "objectID": "src/replicards/replicards.html#table-of-contents",
    "href": "src/replicards/replicards.html#table-of-contents",
    "title": "\nThe Replicards\n",
    "section": "Table of Contents:",
    "text": "Table of Contents:\n\nProtocol\nResults\nConclulsions\nEvolutionary simulations\nIn-class discussion\nPhylogenesis\nMaterials and Methods\nAcknowledgements"
  },
  {
    "objectID": "src/replicards/replicards.html#protocol",
    "href": "src/replicards/replicards.html#protocol",
    "title": "\nThe Replicards\n",
    "section": "Protocol",
    "text": "Protocol\nEach student was provided with a deck of square cards showing an empty \\(8 \\times 8\\) grid. This deck of cards was available to the students for the whole duration of the class.\n\n&lt;img src=\"images/test_image.jpg\" alt=\"grid\" width=\"200\"/&gt;\n&lt;figcaption&gt; Fig. 1 - This is the image caption. &lt;/figcaption&gt;\n\n\nSteps in each generation\nThe experiment consists of repeating a procedure called a generation several times. Each generation consists of the following three steps:\n\n1. The memorization phase (\\(10\\) seconds)\nEach student was provided with a template card, on which some cells of the grid were crossed with an X, forming a pattern. For example, a pattern may look like this:\n\n&lt;img src=\"images/test_image.jpg\" alt=\"grid\" width=\"200\"/&gt;\n&lt;figcaption&gt; Fig. 2 - This is the image caption. &lt;/figcaption&gt;\n\n\nHowever, the template card was provided face down, so that the students could not see the pattern.\nDuring the memorization phase, the students were allowed to look at the pattern on their template card for \\(10\\) seconds and asked to try to memorize it. At the end of the \\(10\\) seconds, the students had to turn the template card face down again.\n\n\n2. The replication phase (\\(30\\) seconds)\nAs soon as they had turned the template face down, they had to copy the observed pattern onto the empty cards they were provided (without being able to look at the template again). They were asked to try to create as many correct copies of the template as possible over \\(30\\) seconds. They were told that translations or rotations of the pattern on the grid count as correct replicas. For example, the following three cards display the same pattern.\n\n&lt;img src=\"images/test_image.jpg\" alt=\"grid\" width=\"200\"/&gt;\n&lt;figcaption&gt; Fig. 3 - This is the image caption. &lt;/figcaption&gt;\n\n\n\n3. The competition phase\nThe templates were collected into a pile called the ‚Äúgeneration record‚Äù, which was put aside. Instead, the replicas were all put into a bag. The number of replicas largely exceeded the number of students. Each student was then randomly assigned a new template card randomly drawn from the bag. The remaining cards in the bag were discarded.\nOnce each student has a new template, a new generation can start. The process is repeated until a desired number of generations is reached.\n\n\n\nRecording results\nFor each generation, the pile of template cards was collected (the ‚Äúgeneration record‚Äù). Therefore, we had one pile of \\(N\\) cards per generation (where \\(N\\) is the number of students in the class). For each pile, the number of copies of each type of pattern was counted. Translated or rotated patterns count as the same pattern (see Fig XXX).\nThe obtained counts were organized into a table."
  },
  {
    "objectID": "src/replicards/replicards.html#results",
    "href": "src/replicards/replicards.html#results",
    "title": "\nThe Replicards\n",
    "section": "Results",
    "text": "Results\nThe class was composed of \\(24\\) students (\\(N=24\\)). At generation 0, the ‚Äúpopulation‚Äù of template cards that had been distributed to the students was composed of the following three patterns (8 copies each):\n\n&lt;img src=\"images/test_image.jpg\" alt=\"grid\" width=\"200\"/&gt;\n&lt;figcaption&gt; Fig. 4 - This is the image caption. &lt;/figcaption&gt;\n\n\nWe named the patterns with the letters A, B and C.\nThe results of the experiment are summarized in the following table.\n\n\n\nGeneration\nA\nB\nC\n\n\n\n\n0\n8\n8\n8\n\n\n1\n16\n1\n2\n\n\n2\n21\n1\n0\n\n\n\nWe can also visualize the number of A, B and C over generations through a line plot as follows.\n\nimport matplotlib.pyplot as plt\nplt.rcParams['figure.figsize'] = [5, 2.5]\nplt.plot([8, 16, 21], label='A')\nplt.plot([8,  1,  1], label='B')\nplt.plot([8,  2,  0], label='C')\nplt.xticks(list(range(3)))\nplt.xlabel('generation')\nplt.ylabel('number of individuals')\nplt.grid()\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nüëÄ The students were asked to comment on the results shown in the table. They made two observations: * Observation 1:\nThe number of A cards increased each generation, while the number of B and C types decreased very quickly. * Observation 2:\nThe total number of A, B and C cards in generations \\(1\\) and \\(2\\) is no longer \\(24\\), even though in each generation one card was assigned to each student (so \\(24\\) in total).\nüí° Students were asked to explain the observations.\n\nInterpretation of Observation 1 (Hypothesis 1):\nThe students noted that reproducing pattern A was easier than reproducing patterns B or C. More copies of A were generated in each generation and, therefore, the bag contained more copies of A than the other types of patterns. As a consequence, students were more likely to receive an A card in the next generation, when cards were randomly drawn from the bag.\nInterpretation of Observation 2 (Hypothesis 2):\nOne student suggested that, due to copying errors, some cards in generations \\(1\\) and \\(2\\) may not correspond to any of the three original patterns, A, B and C. That could explain why the count of A+B+C was no longer \\(24\\).\n\nüîç We then tested the students‚Äô explanations.\n\nTesting Hypothesis 1\nBy looking at cards that went into the bag at the end of generation 0, which had been kept aside, we could test Hypothesis 1. The majority of the cards were of type A, confirming that more copies of A were produced, compared to B and C cards, although the templates were 8 per type and they all had the same amount of replication time. Hypothesis 1 was confirmed.\nTesting Hypothesis 2\nBy inspecting the piles of cards for generations \\(1\\) and \\(2\\) (the ‚Äúgeneration records‚Äù), we found some cards that didn‚Äôt correspond to any of the three original patterns A, B and C. These cards were termed mutants. The mutants were \\(5\\) in generation 1 and \\(2\\) in generation 2 (see Mutants, below). When taking the mutants into account, the total number of cards per generation was indeed \\(24\\). Hypothesis 2 was confirmed.\n\n\nMutants\nMutants at generation \\(1\\):\n\n&lt;img src=\"images/test_image.jpg\" alt=\"grid\" width=\"200\"/&gt;\n&lt;figcaption&gt; Fig. 5 - This is the image caption. &lt;/figcaption&gt;\n\n\nMutants at generation \\(2\\):\n\n&lt;img src=\"images/test_image.jpg\" alt=\"grid\" width=\"200\"/&gt;\n&lt;figcaption&gt; Fig. 6 - This is the image caption. &lt;/figcaption&gt;\n\n\nThus, we updated the table to account for the mutants. This way, all the cards were counted at each generation. For simplicity, we categorized all the mutants under a single class named X.\n\n\n\nGeneration\nA\nB\nC\nX\n\n\n\n\n0\n8\n8\n8\n0\n\n\n1\n16\n1\n2\n5\n\n\n2\n21\n1\n0\n2"
  },
  {
    "objectID": "src/replicards/replicards.html#conclusions",
    "href": "src/replicards/replicards.html#conclusions",
    "title": "\nThe Replicards\n",
    "section": "Conclusions",
    "text": "Conclusions\nWe concluded that the frequency of each type of pattern can change across generations due to chance (after all, the cards composing each new generation are randomly sampled from the bag) but also partly due to another logical principle. The principle is the following: if a pattern is more successful at being replicated than the others, its frequency in the population is more likely to increase. Now that we understand these two principles acting on the frequencies of the competing replicants, we are ready to name them according to the scientific literature:\n\nGENETIC DRIFT: the (unpredictable) effect that random chance has on the frequency of each type of replicant.\nNATURAL SELECTION: the (predictable) bias in the frequency of each type of replicant due to their (different) reproductive success.\n\nThe overall process that the population of \\(N\\) replicants underwent, where the frequencies of the different types change over generations, is called EVOLUTION.\n\nHomework questions\n\nQuestion 1\nWe discussed that evolution is not completely predictable because chance is involved in several parts of the process. However, some scenarios may be more/less predictable than others. As an exercise, try to think about the role that the population size \\(N\\) plays. For example, compare the scenarios where \\(N\\) is very small/very large. Which one will evolve in a more predictable way?\n\n\nQuestion 2\nThe balance between genetic drift and natural selection (see Conclusions to check the terminology) can also depend on the difference in reproductive success (evolutionary biologists use the term fitness) between the different types of replicants. Compare the scenarios where the types are very similar/very different in reproductive success. Which one will evolve in a more predictable way?"
  },
  {
    "objectID": "src/replicards/replicards.html#evolutionary-simulations",
    "href": "src/replicards/replicards.html#evolutionary-simulations",
    "title": "\nThe Replicards\n",
    "section": "Evolutionary simulations",
    "text": "Evolutionary simulations\nThe experiment we performed with the replicards is a demonstration of how evolution by natural selection works. However, it has two important limitations: 1. We only run a couple of generations, but it would be interesting to follow the evolution of the replicards through many generations. 2. We only experimented with a given initial condition (patterns A, B and C in equal frequencies), but it would be interesting to test patterns that are more different or more similar to each other in terms of their reproductive success.\nTo that end, we can use computer simulations to get very quick empirical answers to our questions.\n\nThe virtual replicards\nWe can use the Python programming language to run computer simulations of the replicards‚Äô evolution, by importing the code (XXX). Specifically, we will import the following types of Pthon classes * Organism : objects of this class represent the individuals composing the population (like the replicards); they can reproduce (i.e., create a copy of themselves). * Population : this is a handy class that can be used to generate reports of the evolution of a population; it can visually summarize the results of a simulation with a plot.\nas well as the create function * create : a function that can be used to generate the initial population. It requires to specify three parameters: (1) the type of organism, i.e., whatever name that identifies that type; (2) the (expected) reproductive success of that type of organism; (3) the number of organisms of that type that must be created.\nThe code is imported as follows.\n\nimport random\nfrom evo_sim_objects import Population, create\n\n\n\nSettings\nWe can now set the initial condition (the population at ‚ÄúGeneration 0‚Äù) for our evolutionary simulation.\nFirst, we set how many ‚Äúorganisms‚Äù per type are present at the beginning. Here we simulate the in-class experiment by setting three patterns, 8 copies each, for a total population size of \\(N=24\\).\n\nn_a = 8  # Initial number of A\nn_b = 8  # Initial number of B\nn_c = 8  # Initial number of C\n\nNext, we can decide how easy it will be to replicate each type of pattern, by setting the expected (average) number of copies each pattern get at each generation.\n\nw_a = 12  # Expected number of offspring for A per generation\nw_b =  8  # Expected number of offspring for B per generation\nw_c =  4  # Expected number of offspring for C per generation\n\n\n\nRun the evolutionary simulation\nWe are now ready to run a computer simulation.\n\nimport random\nfrom evo_sim_objects import Population, create\n\n# Initialize population\npop = Population(create('A', w_a, n_a) +\n                 create('B', w_b, n_b) +\n                 create('C', w_c, n_c))\n\n# Population size\nN = pop.size\nprint(\"The population size is N =\", N)\n\n# Keep evolving until fixation is reached\nwhile not pop.fixation:\n    \n    # Reproduction based on fitness\n    pop_offspring = []\n    for org in pop.organisms:\n        pop_offspring += org.reproduce()\n    parents_and_offspring = pop.organisms + pop_offspring\n    \n    # Maintain population size constant at N, the environment's carrying capacity\n    new_pop = random.sample(parents_and_offspring, N)\n    \n    # Update the population\n    pop.update(new_pop)\n\n# Plot results of the evolutionary simulation\npop.plot_evolution()\n\nThe population size is N = 24\n\n\n\n\n\n\n\n\n\nThe graph displays how many individuals of each type are present in each generation, while the total population size remains constant. The simulation stopped when one of the types took over the population completely.\n\n\nRun your own experiments\nIf you are running this as a Jupyter Notebook, you can go back to the Settings and change the parameters that specify the initial conditions. In particular, if you have thought about the Homework questions, it is time for you to put your thoughts to the test! For example, to get the answer to Question 1, you can change the population size to make it very big or very small, and run the simulation several times to see if results become more consistent or more unpredictable. Similarly, for Question 2 you can play with the w_a, w_b and w_c parameters, which control the reproductive success (the ‚Äúfitness‚Äù) of each type. You can make it more unequal (for example, 12, 2, 1) or more similar to each other (for example, 12, 11, 10)."
  },
  {
    "objectID": "src/replicards/replicards.html#in-class-discussion",
    "href": "src/replicards/replicards.html#in-class-discussion",
    "title": "\nThe Replicards\n",
    "section": "In-class discussion",
    "text": "In-class discussion\n\nRandomness\nWhen running the same simulation (with the same initial population) several times, we observed different outcomes. Why is that?\nIn the code, the w_a, w_b and w_c parameters define the average number of offspring per generation. However, the exact number of offspring is randomly assigned (if you are statistically minded, the precise way this is done is by sampling from a Poisson distribution). Moreover, at each generation, \\(N\\) individuals are randomly sampled (to keep the population size constant). These random processes make the evolution to some extent unpredictable. Thus, they simulate the phenomenon that we called genetic drift (see Conclusions to check the terminology).\nThe computer simulations can help us demonstrate empirically the balance between random chance and natural selection in evolving populations (see the paragraph ‚ÄúRun your own experiments‚Äù).\n\n\nMutations\nHowever, a limitation of our computer simulations is that the replication occurs without errors. No mutations are introduced, and therefore, no new types. On the contrary, the experiment performed by the students with the replicards included accidental mutations, allowing for the appearance of mutants.\n\nWhat is a mutation?\n\nWe reasoned that not all modifications qualify as mutations. For example, a card got bent during the replication process. However, when being used as a template, the copies of that card (the ‚Äúoffspring‚Äù) were not bent because the students were only copying the pattern of X marks, not every possible physical feature. Evolution acts on mutations, which are not any kind of modifications but rather the modification of inheritable traits. In the case of the replicards, the inheritable traits are the positions of the X marks, which are a form of digital information. Actual living beings don‚Äôt carry grids of X marks, but rather a sequence of nucleotides making a long molecule called DNA, which is also a form of digital information. Modifying other parts of the organism would constitute a modification but not a mutation. For example, if I lose a finger in an accident, my children will still be born with 10 fingers, not 9. Instead, if the DNA sequence in my ‚Äúgermline‚Äù cells gets mutated in some parts (genes) related to finger development (for example, HoxA and HoxD genes), my offspring could have a number of fingers different from 10, even if I have 10 fingers (as in the case of people with polydactyly).\n\nWhat do you think could happen if we were to continue the replicards protocol for a very very large number of generations?\n\nA student suggested that eventually the population would be taken over by a replicard containing a single X. This pattern could be produced if, at the end of the 30 seconds of the replication phase, a student had just started making a new copy of the template. The prematurely interrupted replication process would leave the card filled with only one X mark. If this card is lucky enough to be sampled from the bag, it could end up dominating the population due to its high reproductive success (high fitness). This high success would be simply due to the fact that many more copies of it could be made in 30 seconds, compared to other more complicated patterns."
  },
  {
    "objectID": "src/replicards/replicards.html#phylogenesis",
    "href": "src/replicards/replicards.html#phylogenesis",
    "title": "\nThe Replicards\n",
    "section": "Phylogenesis",
    "text": "Phylogenesis\nXXX Text here ‚Ä¶"
  },
  {
    "objectID": "src/replicards/replicards.html#materials-and-methods",
    "href": "src/replicards/replicards.html#materials-and-methods",
    "title": "\nThe Replicards\n",
    "section": "Materials and Methods",
    "text": "Materials and Methods\n\nReplicards\nThe replicards were \\(7 \\times 7\\) square grids (of size 7 cm \\(\\times\\) 7 cm), printed on thick paper. The X marks on the cells were drawn by the students using pencils.\n\n\nSimulations\nThe code was written in Python and is available at XXX."
  },
  {
    "objectID": "src/replicards/replicards.html#acknowledgements",
    "href": "src/replicards/replicards.html#acknowledgements",
    "title": "\nThe Replicards\n",
    "section": "Acknowledgements",
    "text": "Acknowledgements"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Replicards",
    "section": "",
    "text": "An interactive way of teaching biological evolution through a card game.\nConcept by Elia Mascolo and Yseult H√©jja-Brichard\n\n\n\n Back to top"
  }
]